# Реализовать функцию my_func(), которая принимает три позиционных аргумента,
# и возвращает сумму наибольших двух аргументов.


# Вариант 1
# Решение конечно не супер - сортировка это грех и операций больше, но зато мы избежали кучи условий
# и получили прекомпактный код
def my_func(a, b, c):
    return sorted([a + b, b + c, c + a])[-1]


# Вариант 2
# Думаю этот вариант будет в 2 раза быстрее при многократном вызове
def my_func2(a, b, c):
    if a > b:
        if b > c:
            return a + b
        elif c > b:
            return a + c
    else:
        if a > c:
            return a + b
        elif c > a:
            return b + c

# def my_func2(a, b, c):
#     if a > b:
#         if b > c:
#             summa = a + b
#         elif c > b:
#             summa = a + c
#     else:
#         if a > c:
#             summa = a + b
#         elif c > a:
#             summa = b + c
#
#     return summa

# Вопрос: СТОИЛО ли использовать не промежуточную переменную и сразу делать return? - отвечу сам себе без промежуточной
# переменной выйгрыш по скорости в среднем на ~3%!
# Вопрос: какой вариант имеет право на жизнь, если 1 вариант в 2 раза медленнее?


print(my_func(10, 20, 30))
print(my_func2(10, 20, 30))

# Не будем ждать милости от природы, а проверим на практике скорость работы этих функций
# from datetime import datetime
#
# for i2 in range(50):
#     start1 = datetime.now()
#     for i in range(9000000):
#         my_func(10, 20, 30)
#     finish1 = datetime.now()
#
#     start2 = datetime.now()
#     for i in range(9000000):
#         my_func2(10, 20, 30)
#     finish2 = datetime.now()
#     print(finish1-start1, finish2-start2, finish2-start2 < finish1-start1,
#           int(((finish2-start2).seconds + (finish2-start2).microseconds/1000000) /
#               ((finish1-start1 + finish2-start2).seconds + (finish1-start1 + finish2-start2).microseconds/1000000) * 100))


"""
0:00:02.807894 0:00:01.319742 True 31
0:00:02.803324 0:00:01.311796 True 31
0:00:02.790890 0:00:01.327775 True 32
0:00:02.774907 0:00:01.303767 True 31
0:00:02.822536 0:00:01.313220 True 31
0:00:02.783794 0:00:01.438516 True 34
0:00:03.005517 0:00:01.345474 True 30
0:00:02.877721 0:00:01.334279 True 31
0:00:02.809322 0:00:01.406152 True 33
0:00:02.798029 0:00:01.306293 True 31
0:00:02.847415 0:00:01.317560 True 31
0:00:02.788200 0:00:01.322819 True 32
0:00:02.792858 0:00:01.323793 True 32
0:00:02.790037 0:00:01.315214 True 32
0:00:02.779986 0:00:01.340170 True 32
0:00:02.859030 0:00:01.313553 True 31
0:00:02.865136 0:00:01.319367 True 31
0:00:02.820113 0:00:01.342507 True 32
0:00:02.855514 0:00:01.342866 True 31
0:00:02.792917 0:00:01.372219 True 32
0:00:02.993650 0:00:01.371330 True 31
0:00:02.873219 0:00:01.365949 True 32
0:00:03.184904 0:00:01.360686 True 29
0:00:03.300820 0:00:01.467496 True 30
0:00:03.183752 0:00:01.519604 True 32
0:00:03.204408 0:00:01.395583 True 30
"""
"""
0:00:03.029128 0:00:01.276638 True 29
0:00:02.931734 0:00:01.282198 True 30
0:00:02.952009 0:00:01.286127 True 30
0:00:02.947373 0:00:01.279703 True 30
0:00:02.943837 0:00:01.276892 True 30
0:00:02.949003 0:00:01.275586 True 30
0:00:03.138318 0:00:01.385409 True 30
0:00:02.906834 0:00:01.273440 True 30
0:00:02.931658 0:00:01.326186 True 31
0:00:02.912419 0:00:01.313376 True 31
0:00:03.143063 0:00:01.392434 True 30
"""
